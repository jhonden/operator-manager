package com.operator.infrastructure.git;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

/**
 * Git Integration Service
 *
 * Handles Git operations for version control
 *
 * @author Operator Manager Team
 * @version 1.0.0
 */
@Service
public class GitIntegrationService {

    private static final Logger log = LoggerFactory.getLogger(GitIntegrationService.class);

    @Value("${git.repository.base-path:./git-repos}")
    private String gitBasePath;

    /**
     * Initialize a Git repository for an operator or package
     */
    public GitResult initializeRepository(String repoName, String description) throws Exception {
        log.info("Initializing Git repository: {}", repoName);

        Path repoPath = Path.of(gitBasePath, repoName);

        // Create directory if not exists
        Files.createDirectories(repoPath);

        try (Git git = Git.init().setDirectory(repoPath.toFile()).call()) {
            log.info("Git repository initialized at: {}", repoPath);

            // Create initial commit with README
            String readmeContent = String.format("# %s\n\n%s\n\nGenerated by Operator Manager System\n",
                    repoName, description != null ? description : "");
            Path readmePath = repoPath.resolve("README.md");
            Files.writeString(readmePath, readmeContent);

            git.add().addFilepattern("README.md").call();
            git.commit().setMessage("Initial commit").call();

            return new GitResult(true, "Repository initialized successfully", repoPath.toString());
        }
    }

    /**
     * Commit operator code changes
     */
    public GitResult commitChanges(Long operatorId, String version, String message,
                                    String filePath, byte[] content) throws Exception {
        log.info("Committing changes for operator: {} version: {}", operatorId, version);

        String repoName = "operator-" + operatorId;
        Path repoPath = Path.of(gitBasePath, repoName);

        try (Git git = Git.open(repoPath.toFile())) {
            // Write file
            Path targetPath = repoPath.resolve(filePath);
            Files.createDirectories(targetPath.getParent());
            Files.write(targetPath, content);

            // Add to git
            git.add().addFilepattern(filePath).call();

            // Commit
            RevCommit commit = git.commit()
                    .setMessage(String.format("Version %s: %s", version, message))
                    .call();

            log.info("Committed changes: {} - {}", commit.getId().getName(), commit.getShortMessage());

            return new GitResult(true, "Changes committed successfully",
                    commit.getId().getName(), commit.getShortMessage());
        }
    }

    /**
     * Create a tag for a version
     */
//     public GitResult createTag(Long operatorId, String version) throws Exception {
//         log.info("Creating tag for operator: {} version: {}", operatorId, version);
// 
//         String repoName = "operator-" + operatorId;
//         Path repoPath = Path.of(gitBasePath, repoName);
// 
//         try (Git git = Git.open(repoPath.toFile());
//              Repository repository = git.getRepository()) {
// 
//             // Get HEAD commit
//             ObjectId head = repository.resolve("HEAD");
// 
//             // Create tag
//             Ref tagRef = git.tag()
//                     .setName("v" + version)
//                     .setObjectId(head)
//                     .setMessage("Release version " + version)
//                     .call();
// 
//             log.info("Tag created: {}", tagRef.getName());
// 
//             return new GitResult(true, "Tag created successfully", tagRef.getName());
//         }
//     }

    /**
     * Get commit history
     */
    public List<GitCommit> getCommitHistory(Long operatorId, int limit) throws Exception {
        log.debug("Getting commit history for operator: {}", operatorId);

        String repoName = "operator-" + operatorId;
        Path repoPath = Path.of(gitBasePath, repoName);

        List<GitCommit> commits = new ArrayList<>();

        try (Git git = Git.open(repoPath.toFile());
             Repository repository = git.getRepository();
             RevWalk revWalk = new RevWalk(repository)) {

            Iterable<RevCommit> log = git.log().setMaxCount(limit).call();

            for (RevCommit commit : log) {
                commits.add(new GitCommit(
                        commit.getId().getName(),
                        commit.getShortMessage(),
                        commit.getFullMessage(),
                        commit.getAuthorIdent().getName(),
                        commit.getAuthorIdent().getEmailAddress(),
                        commit.getCommitTime()
                ));
            }

            return commits;
        }
    }

    /**
     * Get current branch
     */
    public String getCurrentBranch(Long operatorId) throws Exception {
        String repoName = "operator-" + operatorId;
        Path repoPath = Path.of(gitBasePath, repoName);

        try (Git git = Git.open(repoPath.toFile())) {
            return git.getRepository().getBranch();
        }
    }

    /**
     * Create a new branch
     */
    public GitResult createBranch(Long operatorId, String branchName) throws Exception {
        log.info("Creating branch: {} for operator: {}", branchName, operatorId);

        String repoName = "operator-" + operatorId;
        Path repoPath = Path.of(gitBasePath, repoName);

        try (Git git = Git.open(repoPath.toFile())) {
            git.branchCreate()
                    .setName(branchName)
                    .call();

            return new GitResult(true, "Branch created successfully", branchName);
        }
    }

    /**
     * Get changelog since last tag
     */
    public String generateChangelog(Long operatorId, String fromVersion) throws Exception {
        log.info("Generating changelog for operator: {} from version: {}", operatorId, fromVersion);

        String repoName = "operator-" + operatorId;
        Path repoPath = Path.of(gitBasePath, repoName);

        try (Git git = Git.open(repoPath.toFile());
             Repository repository = git.getRepository()) {

            ObjectId fromTag = repository.findRef("refs/tags/v" + fromVersion).getObjectId();
            ObjectId head = repository.resolve("HEAD");

            // Get commits between tag and HEAD
            try (RevWalk revWalk = new RevWalk(repository)) {
                revWalk.markStart(revWalk.parseCommit(head));
                revWalk.markUninteresting(revWalk.parseCommit(fromTag));

                StringBuilder changelog = new StringBuilder();
                changelog.append("## Changes since v").append(fromVersion).append("\n\n");

                for (RevCommit commit : revWalk) {
                    changelog.append("- ").append(commit.getShortMessage()).append("\n");
                }

                return changelog.toString();
            }
        }
    }

    /**
     * Clone a repository
     */
    public GitResult cloneRepository(String remoteUrl, String repoName) throws Exception {
        log.info("Cloning repository: {} from {}", repoName, remoteUrl);

        Path repoPath = Path.of(gitBasePath, repoName);

        try (Git git = Git.cloneRepository()
                .setURI(remoteUrl)
                .setDirectory(repoPath.toFile())
                .call()) {

            log.info("Repository cloned successfully to: {}", repoPath);

            return new GitResult(true, "Repository cloned successfully", repoPath.toString());
        }
    }

    /**
     * Get repository statistics
     */
    public GitStats getRepositoryStats(Long operatorId) throws Exception {
        String repoName = "operator-" + operatorId;
        Path repoPath = Path.of(gitBasePath, repoName);

        try (Git git = Git.open(repoPath.toFile());
             Repository repository = git.getRepository()) {

            int commitCount = 0;
            try (RevWalk revWalk = new RevWalk(repository)) {
                ObjectId head = repository.resolve("HEAD");
                if (head != null) {
                    revWalk.markStart(revWalk.parseCommit(head));
                    for (RevCommit commit : revWalk) {
                        commitCount++;
                    }
                }
            }

            int branchCount = git.branchList().call().size();
            int tagCount = git.tagList().call().size();

            return new GitStats(commitCount, branchCount, tagCount);
        }
    }

    /**
     * Git operation result
     */
    public record GitResult(
            boolean success,
            String message,
            String commitId,
            String shortMessage
    ) {
        public GitResult(boolean success, String message, String data) {
            this(success, message, data, null);
        }
    }

    /**
     * Git commit information
     */
    public record GitCommit(
            String id,
            String shortMessage,
            String fullMessage,
            String authorName,
            String authorEmail,
            long commitTime
    ) {
    }

    /**
     * Git repository statistics
     */
    public record GitStats(
            int totalCommits,
            int totalBranches,
            int totalTags
    ) {
    }
}
